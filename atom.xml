<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Dylandy's Murmur]]></title>
  <link href="http://blog.dylandy.tw//atom.xml" rel="self"/>
  <link href="http://blog.dylandy.tw//"/>
  <updated>2020-01-31T22:41:16+08:00</updated>
  <id>http://blog.dylandy.tw//</id>
  <author>
    <name><![CDATA[Dylandy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用 canvas 進行前端圖片壓縮]]></title>
    <link href="http://blog.dylandy.tw//blog/2020/01/17/li-yong-canvas-jin-xing-qian-duan-tu-pian-ya-suo/"/>
    <updated>2020-01-17T22:24:19+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2020/01/17/li-yong-canvas-jin-xing-qian-duan-tu-pian-ya-suo</id>
    <content type="html"><![CDATA[<p>最近工作上剛好遇到一個需要調校效能的站，在過程中我們運用了許多不同的方法將整體的營運效能往上大幅度的提升，在未來幾篇文章我會討論有關如何提升前端效能的方法，雖然都有些老生常談，但是希望可以給初學者一些方向，當網站效能需要最佳化時可以想到這些方法。</p>

<p>許多人在實作 <a href="https://en.wikipedia.org/wiki/Content_management_system">CMS（Content Management System）</a>時，對於儲存文章內部的圖片時，常常很直觀的透過 JavaScript 在前端將其轉成 base64 編碼之後，與文章本文一起變成一巨大字串傳至後端後直接儲存在資料庫內，這樣的會嚴重的造成效能上的問題，首先是無法進行 <a href="https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video">lazy loading</a>，其次是會使得 api request 封包非常巨大，需要花非常多時間下載，造成使用者等待時間較長，在這樣的狀況下，若是只能調校前端使其效能能夠提升上去，我們可以從壓縮圖片著手，將圖片壓縮之後，api request 容量減少，可以有效的提升下載效率與畫面渲染時間，提升使用者體驗。</p>

<!-- more -->


<p>以下是一個簡單透過 canvas 來進行圖片壓縮的方法。</p>

<p>首先，加入一個我們工作的 canvas tag，這個 canvas 可見與不可見(<code>display: none</code>)皆行，視情形調整是否需要顯示給使用者檢視，並加上一個需要使用者上傳的 input tag，我們會需要一個 image tag 用來暫存使用者上傳的檔案，一樣，這個 image tag 也可以設定為使用者不可見。</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">&quot;&quot;</span> <span class="na">class=</span><span class="s">&quot;before&quot;</span> <span class="na">style=</span><span class="s">&quot;display: none&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;file&quot;</span> <span class="na">name=</span><span class="s">&quot;upload-image&quot;</span> <span class="na">id=</span><span class="s">&quot;upload-image&quot;</span> <span class="na">required</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;canvas</span> <span class="na">style=</span><span class="s">&quot;display: none&quot;</span><span class="nt">&gt;&lt;/canvas&gt;</span></code></pre></div>


<p>我們需要針對這個 input tag 進行事件的設定，當有檔案被上傳之後，我們會將其用 <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> 的方式寫入 canvas 裡面，並將其壓縮成其他不同的格式，下面我們示範轉換成 <a href="https://developers.google.com/speed/webp">WebP 格式</a>，你可以視需求轉換成你所需要的格式。</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;input[name=upload-image]&quot;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;change&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">ReadAndCompress</span><span class="p">(</span><span class="nx">event</span><span class="p">));</span></code></pre></div>


<p>注意到我們上面呼叫了另外一個 <code>function ReadAndCompress</code> 並將 event 傳入，我們在另外一個地方定義了此 function，透過 <code>FileReader</code> 這個內建的檔案讀取 <code>class</code> 將檔案讀出之後，將並將其寫入 canvas 內，並將整個 canvas 的內容透過 canvas 的內容轉成我們所想要的檔案格式，這邊我們轉成 WebP。</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">ReadAndCompress</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">Before</span> <span class="nx">Compression</span><span class="o">:</span> <span class="nx">$</span><span class="p">{(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">size</span><span class="o">/</span><span class="p">(</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1024</span><span class="p">)).</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)}</span> <span class="nx">MB</span><span class="err">`</span><span class="p">);</span></code></pre></div>


<p>首先透過 <code>e.target.files[0].size</code> 可以取得檔案的大小（注意單位為 K)，我們先把它印出來作為壓縮前的大小對照。</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>
 <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsDataURL</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></div>


<p>新增一個 FileReader 並指定檔案以 Base64 的方式讀取。</p>

<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">reader</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">img</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;img.before&quot;</span><span class="p">);</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;canvas&#39;</span><span class="p">);</span>
      <span class="nx">elem</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
      <span class="nx">elem</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">height</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s1">&#39;2d&#39;</span><span class="p">);</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nx">drawImage</span><span class="p">(</span><span class="nx">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">);</span>
      <span class="kr">const</span> <span class="nx">webp</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">toDataURL</span><span class="p">(</span><span class="s2">&quot;image/webp&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span></code></pre></div>


<p>接著我們新增一個 onload 事件，並在確定 loading 結束之後，將圖片寫進 image tag 裡面，這時候，圖片會以剛剛提到的 Base64 格式寫入，並在這個圖片的 onload 事件被觸發，也就是已經確定載入完成之後，我們可以將這張圖片寫入 canvas 來進行壓縮，為了確保壓縮的圖片大小仍舊與原本圖片相同，我們 canvas tag 本身不設定寬高，寬高在圖片載入後設定上去，我們可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage</code></a> 函式將 Base64 圖片直接寫入 canvas 裡面，之後，我們就能透過 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL"><code>ctx.canvas.toDataURL</code></a> 函式將 canvas 的內容轉成 Base64 輸出，<code>toDataURL</code> 的格式如下： <code>toDataURL(type, option)</code> ，一般 <code>option</code> 即是輸出品質，在 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL">MDN</a> 上有提到預設 type 為 png ，若是選定的格式在這個瀏覽器上不支援的話，輸出則會自動變為 png，以上就是一個簡單的利用前端來壓縮圖片的小技巧，下面是整個範例 code，提供參考。</p>

<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="dylandy" data-slug-hash="YzPovQz" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Frontend Image Compress">
  <span>See the Pen <a href="https://codepen.io/dylandy/pen/YzPovQz">
  Frontend Image Compress</a> by dylandy.chang (<a href="https://codepen.io/dylandy">@dylandy</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>


<script async src="https://static.codepen.io/assets/embed/ei.js"></script>




<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;file&quot;</span> <span class="na">name=</span><span class="s">&quot;upload-image&quot;</span> <span class="na">id=</span><span class="s">&quot;upload-image&quot;</span> <span class="na">required</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;p</span> <span class="na">name=</span><span class="s">&quot;before-compression&quot;</span><span class="nt">&gt;&lt;/p&gt;</span>
    <span class="nt">&lt;p</span> <span class="na">name=</span><span class="s">&quot;after-compression&quot;</span><span class="nt">&gt;&lt;/p&gt;</span>
    <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">&quot;&quot;</span> <span class="na">class=</span><span class="s">&quot;before&quot;</span> <span class="na">style=</span><span class="s">&quot;display:none;&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;canvas</span> <span class="na">style=</span><span class="s">&quot;display: none;&quot;</span><span class="nt">&gt;&lt;/canvas&gt;</span>
    <span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">&quot;&quot;</span> <span class="na">class=</span><span class="s">&quot;after&quot;</span> <span class="na">style=</span><span class="s">&quot;display:none;&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;./index.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span></code></pre></div>




<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">ReadAndCompress</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">size</span> <span class="o">=</span> <span class="err">`</span><span class="nx">Before</span> <span class="nx">Compression</span><span class="o">:</span> <span class="nx">$</span><span class="p">{(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">size</span><span class="o">/</span><span class="p">(</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1024</span><span class="p">)).</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)}</span> <span class="nx">MB</span><span class="err">`</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;p[name=before-compression]&quot;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">size</span><span class="p">;</span>
  <span class="kr">const</span> <span class="nx">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FileReader</span><span class="p">();</span>
  <span class="nx">reader</span><span class="p">.</span><span class="nx">readAsDataURL</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="nx">reader</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">event</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">img</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;img.before&quot;</span><span class="p">);</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">result</span><span class="p">;</span>
    <span class="c1">//img.style = &quot;display: true&quot;;</span>
    <span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">width</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">height</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;canvas&#39;</span><span class="p">);</span>
      <span class="nx">elem</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
      <span class="nx">elem</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">height</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s1">&#39;2d&#39;</span><span class="p">);</span>
      <span class="nx">ctx</span><span class="p">.</span><span class="nx">drawImage</span><span class="p">(</span><span class="nx">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">);</span>
      <span class="kr">const</span> <span class="nx">webp</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">canvas</span><span class="p">.</span><span class="nx">toDataURL</span><span class="p">(</span><span class="s2">&quot;image/webp&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
      <span class="kr">const</span> <span class="nx">imgAfter</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;img.after&quot;</span><span class="p">);</span>
      <span class="nx">imgAfter</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">webp</span><span class="p">;</span>
      <span class="c1">//imgAfter.style = &quot;display: true&quot;;</span>
      <span class="kr">const</span> <span class="nx">head</span> <span class="o">=</span> <span class="s1">&#39;data:image/webp;base64,&#39;</span><span class="p">;</span>
      <span class="kr">const</span> <span class="nx">imgFileSize</span> <span class="o">=</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">((</span><span class="nx">webp</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">head</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1000</span><span class="p">)).</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;p[name=after-compression]&quot;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span>
        <span class="err">`</span><span class="nx">After</span> <span class="nx">Compression</span><span class="o">:</span> <span class="nx">$</span><span class="p">{</span><span class="nx">imgFileSize</span><span class="p">}</span> <span class="nx">KB</span><span class="err">`</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">reader</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;input[name=upload-image]&quot;</span><span class="p">)</span>
<span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;change&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">ReadAndCompress</span><span class="p">(</span><span class="nx">event</span><span class="p">));</span></code></pre></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby 2.7 新發布，新功能說明]]></title>
    <link href="http://blog.dylandy.tw//blog/2019/12/27/ruby-2-dot-7-fa-bu-,you-shi-mo-zhi-de-wo-men-guan-zhu-de-di-fang-ni/"/>
    <updated>2019-12-27T13:37:22+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2019/12/27/ruby-2-dot-7-fa-bu-,you-shi-mo-zhi-de-wo-men-guan-zhu-de-di-fang-ni</id>
    <content type="html"><![CDATA[<p>就如往常，Matz 選在聖誕節發布 Ruby 2.7 作為聖誕禮物，那麼這個新版本有什麼特別的呢？又有什麼是未來整個 Ruby 社群的方向呢？</p>

<p>Ruby 2.7 的新功能列表</p>

<ol>
<li><a href="#new-irb">IRB 多行模式與即時文件查閱</a></li>
<li><a href="#array-intersection">Array#intersection</a></li>
<li><a href="#tally">Enumerable#tally</a></li>
<li><a href="#filter-map">Enumerable#filter_map</a></li>
<li><a href="#produce">Enumerable#produce</a></li>
<li><a href="#default-param">Block 預設參數名稱(實驗性)</a></li>
<li><a href="#pattern-matching">Pattern Matching(實驗性)</a></li>
<li><a href="#compaction-gc">Compaction GC</a></li>
<li><a href="#keyword-argument">Keyword Argument</a></li>
</ol>


<!-- more -->


<p>根據 Matz 的說法，本次的版本為最後的 2.x 版本，下個版本將會直接跳到從 2016 開始大家就在引頸期盼的 <a href="https://blog.heroku.com/ruby-3-by-3">Ruby 3.0</a>！</p>

<p>下面是 Matz 在 RubyConf 2019 上針對 Ruby 2.7 的說明。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/2g9R7PUCEXo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


<p>下面，我們開始逐一說明本次 Ruby 2.7 的新功能。</p>

<h2><a name="new-irb">IRB 多行模式與即時文件查閱</a></h2>

<p><video autoplay="autoplay" controls="controls" muted="muted" poster="https://cache.ruby-lang.org/pub/media/irb-reline-screenshot.png" width="576" height="259">
  <source src="https://cache.ruby-lang.org/pub/media/irb_improved_with_key_take3.mp4" type="video/mp4">
</video></p>

<p>新版 irb 支援了多行編輯的功能，只要按 alt-enter 即可換行繼續編輯，我們可以從上面的影片知道，按方向鍵往上可以將整個 block 重新叫回來編輯，另外，按一次 tab 會提示可用的關鍵字，連續按多次 tab 可以進入文件模式，在互動模式下快速查找 rdoc，之後開發者可以在不用離開互動模式的狀況下進行文件的查詢，也可以鼓勵開發者在開發程式的時候編寫 rdoc 。</p>

<h2><a name="array-intersection">Array#intersection</a></h2>

<p>這並不完全算是一個新功能，這是一個簡寫，在 Ruby 2.6 引進一個兩個新功能：<a href="https://ruby-doc.org/core-2.6/Array.html#union-method"><code>union</code></a> 與 <a href="https://ruby-doc.org/core-2.6/Array.html#method-i-difference"><code>difference</code></a>，在 Ruby 2.7 中更進一步將其簡化了，使用方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="nb">p</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>
</span><span class='line'><span class="c1"># [1, 2]</span>
</span><span class='line'><span class="nb">p</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span>
</span><span class='line'><span class="c1"># [1, 2, 3]</span>
</span><span class='line'><span class="nb">p</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>
</span><span class='line'><span class="c1"># [3]</span>
</span><span class='line'><span class="nb">p</span> <span class="n">a</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="c1"># [1, 2]</span>
</span><span class='line'><span class="nb">p</span> <span class="n">a</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="c1"># [1, 2, 3]</span>
</span><span class='line'><span class="nb">p</span> <span class="n">a</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="c1"># [3]</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="tally">Enumerable#tally</a></h2>

<p>回傳一個 Hash ，其中為給定之 Array 中內容物與其個數。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="o">].</span><span class="n">tally</span>
</span></code></pre></td></tr></table></div></figure>


<p>會回傳</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="filter-map">Enumerable#filter_map</a></h2>

<p><code>filter_map</code> method 想要將 <code>select</code> 與 <code>map</code> 結合，從字面上，我們可以知道，這個 method 會回傳一個經過條件選擇的新 Array。</p>

<p>在過去我們如果要做到相同的效果的話，一般都需要使用 chain method 的方式來達到：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span>  <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span><span class="o">.</span><span class="n">map</span><span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Ruby 2.7 中我們可以這樣做</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">filter_map</span><span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="produce">Enumerable#produce</a></h2>

<p>這個功能需要一點點想想力才有辦法理解，讓我們先來看一下此功能的 <a href="https://bugs.ruby-lang.org/issues/14781">proposal</a>:</p>

<blockquote><p>“This method produces an infinite sequence where each next element is calculated by applying the block to the previous element.”</p></blockquote>

<p>沒錯，這個 method 理論上會回傳一個無限長的 Array，讓我看看下面的範例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Enumerable</span><span class="o">.</span><span class="n">produce</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="c1"># [1, 2, 4, 8, 16]</span>
</span></code></pre></td></tr></table></div></figure>


<p>這個 method 長這樣的：<code>Enumerator.produce(initial, &amp;block)</code>，預設上 initial 即為 1 ，我們亦可不傳入值，注意到我們後面的 block 為需要產生這個 Enumerable 的條件，而最後不管我們有沒有給定 <code>take(5)</code> 在記憶體裡面都是一個無限長的大小，只是最後回傳的時候給出最前面五筆，這邊需要特別注意使用，可能在大型產品上會有記憶體管理方面的問題產生。</p>

<h2><a name="default-param">Block 預設參數名稱(實驗性)</a></h2>

<p>Ruby 從 Scala, Closure, Groovy 借鏡了 Block 的預設參數名稱，規則很簡單：第一個參數的預設名稱即為 <code>_1</code>、第二個參數即為 <code>_2</code> ⋯以此類推，下面是一個簡單的範例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">].</span><span class="n">map</span> <span class="p">{</span> <span class="n">_1</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">}</span>
</span><span class='line'><span class="c1"># [2, 4, 6]</span>
</span><span class='line'><span class="c1"># same as [1, 2, 3].map { |x| x * 2 }</span>
</span></code></pre></td></tr></table></div></figure>


<p>你仍舊可以在一般的區域變數使用「底線加上數字」做為變數名稱，但是 compiler 會跳出警告，告訴你這樣是不好的行為，請盡量不要這樣做。</p>

<h2><a name="pattern-matching">Pattern Matching(實驗性)</a></h2>

<p>在演講中，Matz 提到，像是 Pattern Matching 這樣的 Functional Programming 行為，對於 Ruby 來說需要一個全局的重新思考，或許目前的行為在之後會與目前通通不同。在那之前，讓我們看看目前 Ruby 2.7 所提供的 Pattern Matching 使用方法。</p>

<p>Pattern Matching 會回傳一個布林值，當 Pattern 相同時，則會回傳 true 反之亦然。下面是幾個簡單的範例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Array</span>
</span><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span> <span class="k">in</span> <span class="o">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="o">]</span> <span class="c1"># true</span>
</span><span class='line'><span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span> <span class="k">in</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>     <span class="c1"># false</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Hash</span>
</span><span class='line'><span class="p">{</span> <span class="ss">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">c</span><span class="p">:</span> <span class="o">[]</span> <span class="p">}</span> <span class="k">in</span> <span class="p">{</span> <span class="ss">a</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="ss">b</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="ss">c</span><span class="p">:</span> <span class="o">[]</span> <span class="p">}</span>
</span><span class='line'><span class="c1"># true</span>
</span><span class='line'><span class="nb">p</span> <span class="n">a</span>
</span><span class='line'><span class="c1"># 1</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># 合併</span>
</span><span class='line'><span class="k">case</span> <span class="no">JSON</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">read</span><span class="p">)</span>
</span><span class='line'><span class="k">in</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">,</span> <span class="ss">age</span><span class="p">:</span> <span class="n">age</span> <span class="p">}</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">age</span>
</span><span class='line'><span class="k">in</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;no Alice&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a name="compaction-gc">Compaction GC</a></h2>

<p>在 Ruby 2.7 中引入了記憶體壓縮垃圾蒐集演算法，意即將碎片化的記憶體重組的垃圾蒐集演算法，在一些多執行緒程式執行的過程中，可能會造成記憶體使用上的碎片化，長久下來會造成高記憶體使用與效能的下降。</p>

<p>新的 GC method <code>GC.compact</code> 期望能夠將 heap 的碎片化降到最低。</p>

<p>詳細內容請見原 <a href="https://bugs.ruby-lang.org/issues/15626">proposal</a></p>

<h2><a name="keyword-argument">Keyword Argument</a></h2>

<p><strong>這是 Ruby 2.7 與 Ruby 2.6 以前最重要的不同！</strong><br/>
<strong>未來 Ruby 3 之後將不向下相容 Ruby 2.6 的 Keyword Argument</strong></p>

<p>Ruby 2.6 以前的 keyword argument 行為如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="ss">key</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">p</span> <span class="o">[</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="o">]</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">m</span><span class="p">(</span><span class="ss">key</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">#=&gt; [{:key =&gt; 5}, 10]</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">opt</span><span class="o">=</span><span class="p">{},</span> <span class="ss">key</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">p</span> <span class="o">[</span><span class="n">opt</span><span class="p">,</span> <span class="n">key</span><span class="o">]</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">m</span><span class="p">(</span><span class="ss">key</span><span class="p">:</span> <span class="mi">42</span><span class="p">)</span> <span class="c1">#=&gt; [{}, 42]</span>
</span></code></pre></td></tr></table></div></figure>


<p>這真的是非常地令人崩潰的行為，上面的 function 呼叫行為應該是以下這幾種問題的綜合：</p>

<ol>
<li>Wrong Number of Arguments</li>
<li>Combination of Optional/ Rest Argument</li>
<li>Combination with Hash Argument</li>
</ol>


<p>但是 Ruby VM 卻沒有吐出錯誤訊息，所以在 Ruby 2.7 開始，這樣的行為將會被拋棄，在 Ruby 2.7 時只會吐出警告訊息，但是在 Ruby 3 之後就不能執行了，所以 Library 的開發者，如果有使用到這樣的行為，請儘速更新您的軟體，以符合未來的 Ruby 版本。</p>

<h2>Reference</h2>

<ol>
<li>Ruby 3x3: Matz, Koichi, and Tenderlove on the future of Ruby Performance, <a href="https://blog.heroku.com/ruby-3-by-3">https://blog.heroku.com/ruby-3-by-3</a></li>
<li>Ruby 2.7.0 Released, <a href="https://www.ruby-lang.org/en/news/2019/12/25/ruby-2-7-0-released/">https://www.ruby-lang.org/en/news/2019/12/25/ruby-2-7-0-released/</a></li>
<li>Ruby Progress Report by Yukihiro Matsumoto(Matz), <a href="https://www.youtube.com/watch?v=2g9R7PUCEXo">https://www.youtube.com/watch?v=2g9R7PUCEXo</a></li>
<li>New Features, Methods &amp; Improvements in Ruby 2.7, <a href="https://www.rubyguides.com/2019/12/ruby-2-7-new-features">https://www.rubyguides.com/2019/12/ruby-2-7-new-features</a></li>
<li>Enumerator.generate proposal, <a href="https://bugs.ruby-lang.org/issues/14781">https://bugs.ruby-lang.org/issues/14781</a></li>
<li>Ruby 2.7 adds Enumerator#produce, <a href="https://blog.saeloun.com/2019/11/27/ruby-2-7-enumerator-produce.html">https://blog.saeloun.com/2019/11/27/ruby-2-7-enumerator-produce.html</a></li>
<li>Manual Compaction for MRI&rsquo;s GC (<code>GC.compact</code>), <a href="https://bugs.ruby-lang.org/issues/15626">https://bugs.ruby-lang.org/issues/15626</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[恆春食記-夥計鴨肉冬粉]]></title>
    <link href="http://blog.dylandy.tw//blog/2019/04/14/shi-ji-huo-ji-heng-chun-ya-rou-dong-fen/"/>
    <updated>2019-04-14T14:47:38+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2019/04/14/shi-ji-huo-ji-heng-chun-ya-rou-dong-fen</id>
    <content type="html"><![CDATA[<p>在多風的國境之南，冬粉是這邊的一項特產之一，又因為貧瘠的土地，使得畜牧業蓬勃發展，在屏東南邊的大地上，羊、牛、鹿、雞、鴨、鵝…等，都是常見的養殖選項，這樣的碰撞之下，鴨肉冬粉的出現，著實在意料之中。</p>

<p>湯頭帶著鴨骨自然的鮮味，卻不會有鴨肉的腥騷味，我們知道，不論是什麼樣的動物騷味皆是來自氧化的脂肪組織，因此越新鮮的處理，味道越甜美。米粉在剛上桌前因為還沒吸飽湯汁，略顯平淡，這時可以吃吃看他們的小菜，用煙燻的方式處理的小菜非常令人驚艷，尤其推薦海帶與百葉豆腐，薄薄的煙燻味與濃厚的滷汁調和，使得口感更顯精緻，但另一方面，或許是煙燻的時間不易控制，雞腿幾乎是絲狀的質地呈現，失去了雞腿應有的多汁與細膩，實在非常可惜。</p>

<p>推薦給你，恆春夥計鴨肉冬粉。</p>

<!-- more -->


<p><img src="http://blog.dylandy.tw//images/duck_noodle.jpg" alt="鴨肉冬粉" style="width:100%"><br>
<img src="http://blog.dylandy.tw//images/lomi.jpg" alt="滷味" style="width:100%"><br>
<img src="http://blog.dylandy.tw//images/duck_menu.jpg" alt="鴨肉冬粉菜單" style="width:100%"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 inotify 進行資料夾監控]]></title>
    <link href="http://blog.dylandy.tw//blog/2018/06/23/shi-yong-inotify-jin-xing-zi-liao-jia-jian-kong/"/>
    <updated>2018-06-23T14:04:20+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2018/06/23/shi-yong-inotify-jin-xing-zi-liao-jia-jian-kong</id>
    <content type="html"><![CDATA[<p>在撰寫系統時，要監視一個資料夾的變化情形，我們常會寫一個小程式跑一個無限迴圈，隨時監視目標資料夾的狀態，但是這樣的程式不僅浪費系統資源，佔用珍貴的 CPU 時間、對於硬碟 IO 的使用率提昇，也會因為這個程式佔用有限的硬碟頻寬，下面是一個使用無限迴圈實作的簡單資料夾監視程式。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="k">while</span> <span class="nb">true</span>
</span><span class='line'><span class="k">do</span>
</span><span class='line'>  <span class="nv">PASS</span><span class="o">=</span><span class="s2">&quot;$(ls -la | wc -l)&quot;</span>
</span><span class='line'>  sleep 5
</span><span class='line'>  <span class="nv">CURRENT</span><span class="o">=</span><span class="s2">&quot;$(ls -la | wc -l)&quot;</span>
</span><span class='line'>  <span class="k">if</span> <span class="nb">test</span> <span class="k">${</span><span class="nv">CURRENT</span><span class="k">}</span> -gt  <span class="k">${</span><span class="nv">PASS</span><span class="k">}</span><span class="p">;</span> <span class="k">then</span>
</span><span class='line'>    <span class="nb">echo</span> <span class="s2">&quot;file has been added&quot;</span>
</span><span class='line'>  <span class="k">fi</span>
</span><span class='line'><span class="k">done</span>
</span></code></pre></td></tr></table></div></figure>


<!-- more -->


<p>在 Linux kernel 2.6 以後推出了一個稱為 inotify 的子系統 (sub-system)，他延伸了系統對於檔案系統 (filesystem) 的掌控能力，並提供 API 讓使用者的程式能夠了解到檔案系統的變化情形，因此我們若是想要監控使用者對於某個資料夾的變化情形，我們可以用各種 inotify 的 client 端 library 來進行設計，下面是一個使用 Ruby inotify wrapper - rb-inotify 寫的小程式，我們可以看到，我們可以知道使用者這個動作是什麼樣的動作，被做動的檔名與路徑，因此，我們就可以對這些檔案進行操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s2">&quot;rb-inotify&quot;</span>
</span><span class='line'><span class="n">notifier</span> <span class="o">=</span> <span class="no">INotify</span><span class="o">::</span><span class="no">Notifier</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="no">EVENT</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:recursive</span><span class="p">,</span> <span class="ss">:create</span><span class="p">,</span> <span class="ss">:moved_to</span><span class="o">]</span>
</span><span class='line'><span class="n">notifier</span><span class="o">.</span><span class="n">watch</span><span class="p">(</span><span class="n">app_folder</span><span class="p">,</span> <span class="o">*</span><span class="no">EVENT</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">event</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">event</span><span class="o">.</span><span class="n">name</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">event</span><span class="o">.</span><span class="n">flags</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">notifier</span><span class="o">.</span><span class="n">run</span>
</span></code></pre></td></tr></table></div></figure>


<p>因為 inotify 是 Linux Kernel 的子系統，使用 inotify 進行系統的監控不只是節省系統效能，也能將重要的 CPU 時間還給需要的程式使用，亦能減少硬碟 IO 頻寬，因此對於有監控資料夾內容的需求者，這會是一個不錯的選擇，一點小分享，提供給大家參考。</p>

<h2>Reference</h2>

<p><a href="https://en.wikipedia.org/wiki/Inotify">https://en.wikipedia.org/wiki/Inotify</a> <br>
<a href="https://github.com/guard/rb-inotify">https://github.com/guard/rb-inotify</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[將你的程式 Daemon 化]]></title>
    <link href="http://blog.dylandy.tw//blog/2017/12/18/jiang-ni-de-cheng-shi-daemon-hua/"/>
    <updated>2017-12-18T21:21:00+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2017/12/18/jiang-ni-de-cheng-shi-daemon-hua</id>
    <content type="html"><![CDATA[<p>實務上我們常常會希望可以在離開 terminal 的狀況下，程式仍舊持續得執行，有些比較小、比較不需要在意系統資源耗費的程式，我們常可以看到用一些奇怪的手法來達到類似的效果，像是使用 screen 或是 tmux 來將程式跑在背景中，這樣下次登入的時候程式仍舊能夠可以被叫出來，雖然看似方便，但是仍然存在許多問題，例如 tmux 和 screen 所需的記憶體不少，且我們的程式相依於 screen 或 tmux ，當 screen 或 tmux 有任何不可預期的狀況 process 被 kill 掉了的話，我們的程式也會被連帶的受到波及，因此完全獨立的背景執行勢必是需要我們追尋的目標，以下是最近工作上簡單 survey 後的一些有關於如何 Daemon 化程式進行簡單的整理。</p>

<p>本文章主要知識來源於 <a href="https://www.jstorimer.com/blogs/workingwithcode/7766093-daemon-processes-in-ruby">Daemon Processes in Ruby</a> 的教導，希望能夠用較易理解的文字呈現出來。在寫 Daemon 之前，讓我們回頭看看一個知名的 daemonize web server 程式 <a href="https://github.com/rack/rack">rack</a>。我們來看看他將目標 web server daemon 化的程式碼片段，讓我們透過這個程式碼片段來看看是否能夠從中學到如何 daemon 一支程式。</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">daemonize_app</span>
</span><span class='line'>  <span class="k">if</span> <span class="no">RUBY_VERSION</span> <span class="o">&lt;</span> <span class="s2">&quot;1.9&quot;</span>
</span><span class='line'>    <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
</span><span class='line'>    <span class="no">Process</span><span class="o">.</span><span class="n">setsid</span>
</span><span class='line'>    <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
</span><span class='line'>    <span class="no">Dir</span><span class="o">.</span><span class="n">chdir</span> <span class="s2">&quot;/&quot;</span>
</span><span class='line'>    <span class="no">STDIN</span><span class="o">.</span><span class="n">reopen</span> <span class="s2">&quot;/dev/null&quot;</span>
</span><span class='line'>    <span class="no">STDOUT</span><span class="o">.</span><span class="n">reopen</span> <span class="s2">&quot;/dev/null&quot;</span> <span class="p">,</span> <span class="s2">&quot;a&quot;</span>
</span><span class='line'>    <span class="no">STDERR</span><span class="o">.</span><span class="n">reopen</span> <span class="s2">&quot;/dev/null&quot;</span> <span class="p">,</span> <span class="s2">&quot;a&quot;</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="no">Process</span><span class="o">.</span><span class="n">daemon</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我們可以從 else 片段開始看一下，在 ruby 1.9 以後提供了一個 <code>Process.daemon</code> 的 method 來 daemon 化目前的程式，或許有些人會覺得，「嘖！又是一個 Ruby的黑魔法，什麼功能都要包裝在抽象的黑盒子裡面。」，如果你有興趣了解 <code>Process daemon</code> 是如何實作的話，這邊是 <a href="https://github.com/ruby/ruby/blob/c852d76f46a68e28200f0c3f68c8c67879e79c86/process.c#L4817-4860">Ruby MRI 的 C code</a> 可以研究一下，在跳下去研究了一番之後，你會發現其實這段 C code 做的事情跟上面這個 if 片段做的事情本質上是一模一樣的。</p>

<p>ok 那我們來逐一了解一下這個程式碼片段到底做了些什麼。</p>

<h2>Daemonize Process</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
</span></code></pre></td></tr></table></div></figure>


<p>這行 code 巧妙的運用了 fork 的特性：他會 return 兩次，一次是在父程式 (parent process) 回應子程式 (child process) 的 pid，而在子程式的部分回應 nil，因此我們可以知道在父程式的時候 fork 會是 true 而子程式會是 false ，因此父程式會被關閉，而子程式會被保留，變成孤兒程式，那麼問題來了，一個孤兒程式，既然他的父程式已經被砍掉了，那他的 ppid (parent process id) 會是多少呢？答案是 1 ，所有的孤兒程式都會被系統核心接管，而因為被系統核心接管著，我們可以保證他的生命週期是與系統核心綁在一起了，不會因為其他的程式因素而造成此程式無故的終止。</p>

<p>這個步驟可以讓 terminal 認為程式已經被終止了，父程式是使用者執行的程式，子程式為變成孤兒的準 daemon ，因此控制權從程式身上交還給使用者，然後執行到下面這一行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Process</span><span class="o">.</span><span class="n">setsid</span>
</span></code></pre></td></tr></table></div></figure>


<p>執行 <code>Process.setsid</code> 會進行以下三件事情：</p>

<ul>
<li>系統新增一個新的 session 並目前的程式指定為新 session 的 leader</li>
<li>系統新增一個新的 process group 並指定目前程式為新 process group 的 group leader</li>
<li>因為此程式與 terminal 本身處於不同的 process group ，因此此程式對於 terminal 沒有控制能力</li>
</ul>


<p>為了了解上面三件事情，我們需要從 Linux 系統更深的方向理解起。</p>

<h2>Process Groups 與 Session Groups</h2>

<p>Process groups 和 session groups 皆是用於行程控制的，在這邊「行程控制」意味著終端機控制程式的方法。
我們從 process groups 開始討論起吧。</p>

<p>每個程式皆屬於一個程式群組，而這個程式群組皆是由一群互相有關聯的程式所組成的，我們稱為父程式與子程式，子程式的生命週期會與父程式的生命週期互相連動，但父程式卻不受制於子程式的生命週期。一般來說，系統會指定一個隨機的 id 給這個程式群組，但是我們也可以透過下面的這個指令來指定群組的 id。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Process</span><span class="o">.</span><span class="n">setpgrp</span><span class="p">(</span><span class="n">new_group_id</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我們將下面的這段程式輸入至 <code>irb</code> 我們可以發現他們的值是相同的，一般來說，Process group 的 id 會和這個 process group 的最主要的父程式的 pid 相同。打個比方，如果我們在終端機下執行了 <code>irb</code>，那麼 <code>irb</code> 的 process group id 應該會與終端機的 pid 相同，因為 <code>irb</code> 是屬於終端機的子程式。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="no">Process</span><span class="o">.</span><span class="n">getpgrp</span>
</span><span class='line'><span class="nb">puts</span> <span class="no">Process</span><span class="o">.</span><span class="n">pid</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我們看下面這段程式，雖然子程式有自己的 pid ，但是因為子程式與父程式皆屬於相同的 process group ，所以他們的 process group id 是相同的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="no">Process</span><span class="o">.</span><span class="n">pid</span>
</span><span class='line'><span class="nb">puts</span> <span class="no">Process</span><span class="o">.</span><span class="n">getpgrp</span>
</span><span class='line'>
</span><span class='line'><span class="nb">fork</span> <span class="p">{</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="no">Process</span><span class="o">.</span><span class="n">pidputs</span> <span class="no">Process</span><span class="o">.</span><span class="n">getpgrp</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>從這邊我們可以往回看到前面所說的孤兒程式。我們透過將一個程式的父程式從終端機（因為我們從終端機中將其開啟），設定為系統（pid 為 1），這樣，在終端機關閉的狀況下，孤兒程式仍舊會繼續執行，不會受到終端機的生命週期所影響他的存在。</p>

<p>然後是 session group。</p>

<p>Session group 是更高一層的抽象概念，每個 session group 中會含有非常多個 process group。一個使用者登入至系統後，系統會新增一個 session 給此使用者，這個使用者在這個 session 的過程中所產生的程式皆會屬於這個 session，因此一個 session group 中會含有許多不同的 process group。我們看看以下這個指令。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>git log <span class="p">|</span> grep shipped <span class="p">|</span> less
</span></code></pre></td></tr></table></div></figure>


<p>這些指令都各自為不同的 process group 但是，因為他們是由不同的 process 所產生的 child process，但是一個簡單的 Ctrl-C 就可以將他們通通關閉，這是因為他們皆屬於同一個 session group，當我們開啟一個新的 shell 的時候，這個動作將會啟動一個新的 session group，亦即，在這個 shell 裡面所做的行為都屬於同一個 session group，而對於大部分的程式而言 session group 會與終端機連通，但，有些卻不會，那就是 daemon。</p>

<p>你的終端機在管理 session group 上面使用了一個蠻有趣的方法：將指令傳至 session leader，而 session leader 會將此指令廣播至此 session 中的所有 proccess group，當需要被執行的程式收到此指令，程式即執行此指令。</p>

<p>在 Linux 上有一個 <a href="http://shell-storm.org/shellcode/files/syscalls.html">system call</a> 可以取得目前的 session group id - <a href="http://man7.org/linux/man-pages/man2/getsid.2.html"><code>getsid(2)</code></a>，但是在 <a href="https://ruby-doc.org/core-1.9.3/Process/Sys.html">Ruby 2.0 前的核心 library</a> 裡面沒有實作這個介面，如果你真的想要對 session group id 進行管理，可以用 <code>Process.setsid</code> 來產生一個新的 session group 並將其 id 存下來，留著往後使用。</p>

<p>讓我們回到前述的 Rack 範例，第一行是新增一個子程式並關閉父程式，終端機發現其與父程式間的連結斷裂了，所以將控制權還給使用者，但此時被新增的子程式仍舊與繼承著父程式的 process groud id 與 session id，因此，在此時這個子程式並不是這些 process group 與 session group 的 leader，因此，雖然終端機將控制權交還給使用者，我們執行在背景的子程式仍舊與目前的終端機有著一絲一縷的關聯，如果此時終端機所在的 session 被中斷了，或是有人傳訊息給終端機要求關閉我們可憐的子程式，這個子程式也又只能被迫關閉，因此，我們希望完全與終端機斬斷連結，才能完整地成為一個 daemon。</p>

<p>透過執行 <code>Process.setsid</code> ，我們能夠將目前的子程式設定為一個新的 process group 與 session group 的 leader，但是需要特別注意的是：如果這個指令被執行的對象目前已經是 process group 的 leader 就會失敗，因此，要確定對象是子程式才能被正確執行，同時，由於我們產生了一個新的 session group，理論上它應該要被指定一個終端機來給使用者互動，雖然在這邊顯然的並沒有，但為了避免不必要的錯誤，我們仍舊將其離開，以確保其完全的與終端機分離，除了系統，其他人不能隨便將其關閉，換句話說，它現在自由了，沒有人可以管它了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
</span></code></pre></td></tr></table></div></figure>


<p>之後，Rack 將目前的工作目錄切換至系統根目錄，這步驟並不是必要的，但是就如同上面的將終端機關閉一樣，這是一個保險，避免程式因為工作目錄消失而被關閉的窘境發生。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Dir</span><span class="o">.</span><span class="n">chdir</span> <span class="s2">&quot;/&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在避免了因為工作目錄消失而被關閉的情形，我們需要考慮另外一個問題 &ndash; 輸出，不論是正確的 stdout 或是錯誤的輸出 stderr 都需要被忽略，因此我們將這些串流資訊導引至 <code>/dev/null</code>，你可能會問說，奇怪，那我們怎麼不能直接將它的輸出直接關閉？因為我們不曉得這個程式是否需要存在著標準輸入輸出而能夠正常執行，說不定哪天，因為我們將它關閉而造成後續的執行問題是不容易找到的，因此將其轉到 <code>/dev/null</code> 其他軟體需要這些資訊的時候，可以自由導出，不會受到影響。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">STDIN</span><span class="o">.</span><span class="n">reopen</span> <span class="s2">&quot;/dev/null&quot;</span>
</span><span class='line'><span class="no">STDOUT</span><span class="o">.</span><span class="n">reopen</span> <span class="s2">&quot;/dev/null&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span>
</span><span class='line'><span class="no">STDERR</span><span class="o">.</span><span class="n">reopen</span> <span class="s2">&quot;/dev/null&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上，就是從 Ruby 的角度來看如何將一個程式 daemon 化的簡單概念。
希望能夠幫助到有需要的人。</p>

<h2>Reference</h2>

<ol>
<li>Daemon Processes in Ruby, <a href="https://www.jstorimer.com/blogs/workingwithcode/7766093-daemon-processes-in-ruby">https://www.jstorimer.com/blogs/workingwithcode/7766093-daemon-processes-in-ruby</a></li>
<li>程序管理與 SELinux 初探, <a href="http://linux.vbird.org/linux_basic/0440processcontrol.php">http://linux.vbird.org/linux_basic/0440processcontrol.php</a></li>
<li>Linux System Call Table, <a href="http://shell-storm.org/shellcode/files/syscalls.html">http://shell-storm.org/shellcode/files/syscalls.html</a></li>
<li>Ruby Core 1.9 Library, <a href="https://ruby-doc.org/core-1.9.3/">https://ruby-doc.org/core-1.9.3/</a></li>
<li>Ruby Core 2.6.5 Library, <a href="https://ruby-doc.org/core-2.6.5/">https://ruby-doc.org/core-2.6.5/</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[台中食記-麵屋田宗]]></title>
    <link href="http://blog.dylandy.tw//blog/2017/10/07/tai-zhong-shi-ji-mian-wu-tian-zong/"/>
    <updated>2017-10-07T16:18:42+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2017/10/07/tai-zhong-shi-ji-mian-wu-tian-zong</id>
    <content type="html"><![CDATA[<p>TL;DR 田宗的用心與水準真心不錯，有機會的話請一定要去吃吃看。</p>

<p>本來想要在吃完的時候就來寫這篇食記了，在台灣吃過這麼多家拉麵店，麵屋田宗是第一家讓我感受到那種對拉麵的熱愛，那種狂熱與堅持，再再都是那麼的觸動我心。經過幾個禮拜的沈澱之後，我決定試著把我對於麵屋田宗的一些感想用我拙劣的文字描繪出來。</p>

<p>因為求學的關係，之前在台北生活了七年的時間，身為一個台中人，在網路上看到任何有關於台中的消息總是會特別的關注，說來慚愧，因為在台北待的太久的關係，對於台中餐廳的認識並不比許多台北人來的高明，與田宗的邂逅也是在網路上看到一名廚師網友的大力推薦才初次耳聞，文中的那種英雄惜英雄讓我特別有帶入感，也讓我對於造訪田宗的旅程更是期待。</p>

<p>或許是我來到店家的時間有點晚了，到達餐廳時已經臨界中午打烊，上一組客人帶著滿足的笑容與我擦身而過。推開木製的大門，醬油與味淋的清香撲面而來，或許是生活習慣的關係，對於醬油與味淋的味道感到特別的令人安心，有別於其他拉麵店總是會播放各種日本音樂，店內飄蕩著輕柔和緩的爵士樂，顯示出了店主心中小小的反動。</p>

<!-- more -->


<p>忘記在哪裡看到的拉麵師傅這麼要求自己的拉麵的：「一碗好吃的拉麵不能是赤裸的，麵是麵、湯是湯，這樣不行。」簡單的一句話包含很多經驗在裡頭，就如湯與麵條的選擇，同時也是麵條硬度的選擇；我的湯頭是厚重系的還是清淡系的？一般來說厚重系的湯頭需要搭配較粗、較捲也較硬的麵條來帶起湯頭，反之清淡、清雅的湯頭需要搭配較為細直硬度 Al Dente<sup>[1]</sup> 的麵條為佳。</p>

<p>這次點的是招牌豚骨拉麵，看著店主將盛好醬汁的麵碗放至麵鍋上預熱，富有節奏感的攪拌醬汁，像跳舞般地同時照顧叉燒地燒炙，各種細節皆面面俱到做的無微不至，那種在時間與節奏的搭配上的和諧感，在上菜前已是一場視覺與嗅覺的享受。</p>

<p><img src="http://blog.dylandy.tw//images/tamune_tonkotsu_ramen.jpg" alt="豚骨魚介拉麵" /></p>

<p>剛上手時，湯頭的清香溢滿整個鼻腔，淡雅中帶著豚骨的積極氣息，用湯匙輕帶一下液面，與常見的各家豚骨湯頭的濃稠不同，輕柔的觸感非常特別，記憶中的博多系豚骨湯頭是一種用大火長時間滾出來的濃厚，帶著強烈的豬骨味與豬膠質黏稠與醇厚的表現<sup>[2]</sup>，在吃的較為清淡的東京豚骨湯頭自然地朝向另一方向發展，加入了魚干（煮干）與柴魚等海鮮元素，使得豬味下降，更帶入一些鮮甜味道進入其中，保留了豚骨的油脂香，但是透過海鮮湯頭將其味道中和，使得整體味道更加調和，在品嚐的過程中較不會因為油膩感而產生不適<sup>[3]</sup>。田宗的湯頭亦選用了豚骨魚介的類別，但是在傳統的豚骨魚介上進行了巧妙的調整，與其他豚骨魚介店家相比，田宗的湯頭在調味上下了很大的一番功夫，將豬骨熬煮後會產生的腥臊味掩去，並提升豬肉本身的香氣，又可以吃到魚介的鮮甜，那種猶如在海邊騎著一頭小豬般暢快的感覺是怎麼回事呀。</p>

<p><video style="width:100%" autoplay="autoplay" loop>
  <source src="http://blog.dylandy.tw//videos/soup.mp4">
</video></p>

<p>田宗的麵條選擇在第一時間讓人覺得蠻有趣的，在較不濃厚的湯頭下，選擇了像是烏龍麵般較粗的麵條；當開始吃麵的時候那種平衡感體現出來時，才能知道店主的用心，店主習慣將麵條煮得相對 Al Dente 更軟一些，對於吃習慣二郎系拉麵的鐵麵朋友可能會有點不適應，若是到訪的話，請務必記得跟老闆提醒不要太軟，而這樣較軟的前提下，粗麵較能帶起湯汁的特性，讓湯與麵結合的相當完美，原本擔心的赤裸麵條並沒有發生。</p>

<p>常常在吃拉麵的時候，因為油膩感與過鹹的調味，麵條吃到一半時，煩悶與膩味感層層湧現，這時，我會將專注力從湯頭與麵條轉移到配菜上，在化解油膩與平淡的方法中，最常見的調味法是透過辛香料的添加，將鼻腔與口腔中的味道完全洗掉，讓我們有種清爽感，例如：生洋蔥絲；另一種方法則是使用酸性調味，將油脂的黏膩感洗去，就如德國豬腳搭配的酸菜般，也如日本拉麵中的筍乾的存在。或許是害怕筍乾的味道搶走湯頭的風采，許多的拉麵店特別將筍乾洗了又洗，使得其味道變得相當清淡，只保留了爽脆的口感，但卻讓筍乾的酸味失去，同時也失去了那種解膩的功能。在吃第一口時候，田宗的筍乾口味是懷念的，或許是因為爺爺家在竹山的關係，對於台灣的筍乾口味非常熟悉，從小就聽家中長輩說竹山產的筍乾大部分都是外銷到日本做拉麵，這種懷念感就像是把我帶回到竹山家的餐桌上那般懷念。和店主聊天的過程中店主說這是嘉義的筍乾，因為台灣的筍乾品質比日本產的好很多，所以選擇使用台灣本產的筍乾。</p>

<p><img src="http://blog.dylandy.tw//images/tamune_yuzu.jpg" alt="湯裡的彩蛋柚子皮" style="width:100%"/></p>

<p>店主是一個對於味覺平衡非常厲害的廚師，一碗湯麵中，可以看到許多為了味覺平衡做作的努力，在西方的廚藝學校中流行著這麼一句話：「如果鹽是讓你的食物增色，那麼酸能使得你的食物驚艷，真正出色的關鍵。」，知名廚藝 YouTuber - <a href="https://www.youtube.com/channel/UCzH5n3Ih5kgQoiDAQt2FwLw">Brothers Green Eats</a>也說過類似的話, If the salt is bringing out and enhancing the flavour of the food, the acidity is just going to make it brighter and sing to the heaven.<sup>[4]</sup>在拉麵湯中的小彩蛋是一絲一絲的柚子皮，微酸的氣息與淡淡的柚子清香，柚子皮的淡淡苦澀口感，讓湯頭的黏膩與鹹澀得到紓緩，確實是相當聰明的方法，在此前，我只有在京都的豬一拉麵有吃過柚子皮入湯的方法，但是當時在豬一時柚子並不是店主的推薦吃法，反而是若我們有些膩味可以添加的選配，在田宗店主將柚子皮與湯的結合非常引人入勝，是一大佳作呢。</p>

<p>「每家拉麵店都有他追尋的味道。」店主這麼說著眼神中閃耀出專注的光芒，像是在闡述也像是在與自己對話，猶如問道於麵般的執著，店主在拉麵的腳步上，已經超出許多其他店家許多了。</p>

<p>推薦給您，麵屋田宗。</p>

<h3>Reference</h3>

<p>[1] <a href="https://en.wikipedia.org/wiki/Al_dente">Al dente</a><br>
[2] <a href="https://ja.wikipedia.org/wiki/%E5%8D%9A%E5%A4%9A%E3%83%A9%E3%83%BC%E3%83%A1%E3%83%B3">博多ラーメン</a><br>
[3] <a href="http://kenshin.hk/2013/04/22/%E5%8A%8D%E5%BF%83%E6%8B%89%E9%BA%B5%E7%A0%94%E7%A9%B6%E6%89%80-3-%E8%B1%9A%E9%AA%A8%E6%8B%89%E9%BA%B5%E7%9A%84%E8%B5%B7%E6%BA%90%EF%BC%8C%E7%99%BC%E5%B1%95%E6%B5%81%E8%A1%8C%E4%B9%8B%E8%BB%8C/">豚骨拉麵的起源，發展流行之軌跡</a><br>
[4] <a href="https://www.youtube.com/watch?v=TCVTOa01uN8">15 Mistakes Most Beginner Cooks Make</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[身為一個程式設計師，或許我們可以為台灣的數學教育做點什麼]]></title>
    <link href="http://blog.dylandy.tw//blog/2017/02/06/shi-yong-coffeescript-chan-sheng-ren-yi-duo-bian-xing/"/>
    <updated>2017-02-06T14:27:44+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2017/02/06/shi-yong-coffeescript-chan-sheng-ren-yi-duo-bian-xing</id>
    <content type="html"><![CDATA[<p>最近在練習 coffeescript 的時候，一直想要寫個小東西來玩玩，昨天晚上在回家的路上一邊騎車一邊想到，未來的世界、未來的教育，或許我們這些程式設計師都有參與的責任，或許編寫一些對於教育有關的程式也會是我往後的一個目標吧。帶著這樣的想法，開始思考著最近在網路上看到的影片</p>

<iframe src="https://embed.ted.com/talks/conrad_wolfram_teaching_kids_real_math_with_computers" width="640" height="360" frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>


<p>現在已經是資訊化的時代了，過去我們苦心積慮的想要讓孩子們學好算數，可以用紙筆進行高難度的運算，但是這些運算，在電腦普及、智慧型手機人手一支的現代，或許值得我們重新思考，我們學習數學運算的目的是什麼呢？這些能力能夠讓我們在數學成就上面得到什麼發展嗎？是不是這些能力讓我們在過往的學習路途上扼殺了許多可能的數學天才呢？我們是不是又因為一個人有著不錯的數學計算能力，就理所當然的認為他有數學天份呢？這些問題應該是進入了資訊化社會以後的我們，不論是不是老師，我想我們都應該問自己這樣的問題。我們能不能改變什麼，透過這些我們已經身在其中的機器，幫助我們運算，是不是能夠幫助我們學習數學的過程中，能夠學習得更透撤，更有系統呢？</p>

<!-- more -->


<p>在影片中， Conrad Wolfram 示範了一個多邊形的範例，這個範例可以讓年紀很小的小朋友都可以很容易了解極限的概念。我試著把這個小玩具製作出來，透過這個小玩具不僅可以讓自己瞭解 coffeescript 的撰寫，也希望自己可以為台灣的數學教育做出一點貢獻，身為一個有能力可以編寫程式來為我們的下一代貢獻的人，我覺得沒有什麼比這更有意義的事了。</p>

<p>專案頁面：<br>
<a href="https://github.com/dylandy/polygenJS">https://github.com/dylandy/polygenJS</a></p>

<p>這是一個 jQuery plugin ，你只要把 polygen.js 引入到你的頁面中，你就可以輕易的帶入你想要的參數畫出你想要的圖形。</p>

<p><img src="http://blog.dylandy.tw//images/template.png" alt="template diagram" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[設定 public key 進行 SSH 連線]]></title>
    <link href="http://blog.dylandy.tw//blog/2016/05/20/she-ding-public-key-jin-xing-ssh-lian-xian/"/>
    <updated>2016-05-20T19:06:07+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2016/05/20/she-ding-public-key-jin-xing-ssh-lian-xian</id>
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;身為一個宅宅工程師，對於使用 ssh 連線登入遠端主機是家常便飯的事情，但是也常常會因為 ssh port 被一些惡意程式攻擊，導致主機的帳號密碼被猜到，從而被迫換機器或是全機重灌等等的悲劇。
有些系統工程師為了避免這樣的風險，把 ssh port 從預設的 22 port 搬移到其他的 port 上，希望能夠躲過大部分的機器人掃描，並且要求使用者的密碼要足夠複雜，但是相對於這些方法，使用 public key 來登入 ssh 主機似乎是最安全的作法，首先，足夠長度的 key length 能夠有效防止攻擊者的攻擊，並且以目前的科技與已知的演算法，並沒有有效的方法進行 key 破解，<a href="https://en.wikipedia.org/wiki/Integer_factorization">畢竟 key 的拆解</a>是一個 <a href="https://en.wikipedia.org/wiki/NP-hardness">NP-hard 的問題</a>，因此能夠使用 public key 來進行連線登入的話是一個較為安全的連線方法。</p>

<!--more-->


<ul>
<li>要使用 public key 登入遠端伺服器的第一步，就是先產生 client 端的 public key，可以參考 <a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/">Github 的範例文件</a></li>
</ul>


<script src="https://gist.github.com/dylandy/56e5ed043d616a892d0e82109910b99b.js"></script>


<p>這邊建議使用 2048 bit 以上的安全加密，目前現行的商用網站加密層級至少都達到了 2048 bit ，因此，為了安全性考量，4096 bit 是很有必要的。<br></p>

<ul>
<li>使用 ssh-copy-id 工具將我們剛剛產生的 public key 上傳到伺服器上，這個程式會在伺服器上使用者的家目錄下 .ssh 資料夾新增一個 authorized_keys 檔案，並將 client 的 public key 存在裡面，因此如果不想使用 ssh-copy-id 的人，可以自己新增一個 authorized_keys 檔案也是可以的。</li>
</ul>


<script src="https://gist.github.com/dylandy/571ace32c9ad3d548c6ae87c002ba278.js"></script>


<p>使用 Mac 的朋友如果要使用 ssh-copy-id 的話，需要另外安裝，這個程式沒有包含在 ssh 裡面，可以透過 brew 來安裝。</p>

<script src="https://gist.github.com/dylandy/bade9ef40829f51499a5a1839dec8403.js"></script>


<ul>
<li>最後要修改 /etc/ssh/sshd_conf 這個檔案，找到 PubkeyAuthentication 將 no 改成 yes，並將 PasswordAuthentication 由 yes 改成 no，限制只能透過 public key 來進行登入</li>
</ul>


<script src="https://gist.github.com/dylandy/7b2877ce6aa9f075312b99a23ddefdcd.js"></script>


<p>設定完成以後，請記得將 ssh 服務重開。</p>

<p>這樣往後就可以透過 public key 來登入了，也省下每次登入都要打一大串密碼的困擾了。</p>

<script src="https://gist.github.com/dylandy/636aa794d2cf02e33b3e72b8721b2240.js"></script>


<p>PS: 可以透過在 .ssh 資料夾下新增一個 config 檔案，將常用的登入設定寫進去，也可免去每次登入都要輸入一大堆 ip 和 domain 的麻煩，下面是一個簡單的範例。</p>

<script src="https://gist.github.com/dylandy/2aa177ffcff15e10d5657f869a0270c2.js"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Web Framework : 觀察與概念]]></title>
    <link href="http://blog.dylandy.tw//blog/2016/04/06/ruby-web-framework-xue-xi/"/>
    <updated>2016-04-06T00:00:00+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2016/04/06/ruby-web-framework-xue-xi</id>
    <content type="html"><![CDATA[<p><br></p>

<h3>緣起</h3>

<p>前前後後寫 Ruby 也寫了一陣子，用習慣了別人寫的套件、別人寫的 framework 以後，慢慢的也對於各種套件撰寫的原理有了些好奇，開始想要自己編寫一些屬於自己的套件和 framework 來了解一些背後的原理與方法，從過年前到最近，花了一點時間來自己摸索怎麼用 Ruby 來寫一個 web framework ，在過程中學到了許多東西，慢慢的從很多方向來思考 framework 需要什麼。
在這篇裡面我會先將各個模組說明，之後會一個一個來討論。</p>

<!--more-->


<h3>觀察</h3>

<p>從以前就不喜歡看一堆的 document 來學東西，我喜歡從自己的發現中學習，高見龍前輩曾經在日本 RubyKaigi 上發表「<a href="http://rubykaigi.org/2013/talk/S41">Code Reading, Learning More about Ruby by Reading Ruby Source Code</a>」，因此我開始觀察不同的 web framework 試試看能不能有什麼發現。</p>

<h4>Web Framework 都有一個 config.ru 檔案？<br> 這是要做什麼的？</h4>

<p>首先呢，先查了一些資料，意外的發現網路上沒有太多關於 config.ru 單獨的說明，但是可以大致上了解， config.ru 是一個 Rack 的設定檔與執行檔，那什麼是 Rack 呢？</p>

<blockquote><p>Rack is a nice Ruby-fied replacement for CGI.<br>
Rack sits between all the frameworks (Rails, Sinatra, Rulers) and all the app servers (thin, unicorn, Rainbows, mongrel) as an adapter.<br>
Rack is a convenient way to build your Ruby app out of a bunch of thin layers, like a stack of pancakes. The layers are called middleware. Or pancakes, why not?<br></p>

<p> &mdash; <a href="http://codefol.io/posts/What-is-Rack-A-Primer">What Is Rack? : a Primer</a></p></blockquote>

<p>簡單的說，Rack 就是一個用 Ruby 做的 <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a> ，它在應用程式和伺服器之間做資料的轉換和處理，可以讓我們用更邏輯的方式來撰寫程式，對於 Ruby framework 的抽象化有很大的幫助，而 config.ru 就是 Rack 的執行點，也可以稱為設定檔，而 config.ru 是用純 Ruby 的語法所寫成，理論上，我們可以把 framework 的所有的東西都寫在 config.ru 裡面，就能執行了。但是，我們不要，也不應該這麼做，對於 Ruby 的程式撰寫，其中最重要的一個目的在於「<a href="https://en.wikipedia.org/wiki/Semantic-oriented_programming">語意化</a>」，用以提升程式<strong>可再利用性</strong>、<strong>可維護性</strong>、<strong>提升開發速度</strong>，為了維持語意化的目的，使用多檔案的架構勢必是不可少的，那，如何區分資料夾呢？</p>

<h4>每個 MVC 架構的程式對資料夾的分配好像都很類似</h4>

<p>以前寫過的各種 MVC 框架的結構感覺上都大同小異，將 Modal , Controller , View 分開來放，將設定檔放在 config 資料夾內，可以讓設定檔和程式的邏輯分開，將 Modal , Controller , View 分開，可以在設計上更加方便，至於什麼是 MVC 架構呢？<br></p>

<blockquote><p>Model–view–controller (MVC) is a software architectural pattern for implementing user interfaces on computers. It divides a given software application into three interconnected parts, so as to separate internal representations of information from the ways that information is presented to or accepted from the user.<br></p>

<ul>
<li>The model directly manages the data, logic and rules of the application.<br></li>
<li>A view can be any output representation of information, such as a chart or a diagram. Multiple views of the same information are possible, such as a bar chart for management and a tabular view for accountants.<br></li>
<li>The third part, the controller, accepts input and converts it to commands for the model or view.
<br>
<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Wikipedia - Modal View Controller</a></li>
</ul>
</blockquote>

<p>大部分的 framework 都有如以下的結構：</p>

<p><br><img src="http://blog.dylandy.tw//images/tree-structure.png" alt="tree structure" /></p>

<h4>Public 可以放什麼東西呢？</h4>

<p>在 Public 資料夾中，一般是放靜態檔案的地方，系統裡的靜態檔案一般可以分成以下的幾種：</p>

<ul>
<li>asset ( css / JavaScript )</li>
<li>image</li>
<li>other format file ( <em>.pdf / </em>.docs / *.xlsx &hellip; )</li>
</ul>


<p>在 Rack server 的機制裡面，這個資料夾的內容可以直接被下載，用以增加頁面加載的速度，不用透過自身 server 的重新 render ( 像是 nodejs 的 pm2 的作法 ) 這樣對於有大量靜態資源的頁面來說，是個較容易省下計算資源和增加連線效率的方法。</p>

<h4>Rakefile 是做什麼的呢？</h4>

<p>Rake 是一個 Ruby 中的任務自訂小工具，我們可以透過在 Rakefile 裡面自己撰寫一些任務，來幫忙我們加速開發與上線的麻煩點，Rakefile 裡面使用到的都是標準的 Ruby 語法，也就是說，我們可以用簡單的幾行 Ruby 就可以進行一些專案上的控制，如：DB migration, install project &hellip;我們之後會討論如何撰寫 Rakefile 的任務。</p>

<h3>簡單總結</h3>

<ul>
<li>config.ru 是一個 Rack-based 的 framework 主程式</li>
<li>MVC 框架的基本資料夾格式為：

<ul>
<li>app/

<ul>
<li>modal/</li>
<li>view/</li>
<li>controller/</li>
</ul>
</li>
<li>public/</li>
</ul>
</li>
<li>Public 是靜態檔案的集散地</li>
<li>Rakefile 定義了這個程式或 framework 所使用到的一些指令行任務</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://blog.dylandy.tw//blog/2016/03/14/hello-world/"/>
    <updated>2016-03-14T23:13:07+08:00</updated>
    <id>http://blog.dylandy.tw//blog/2016/03/14/hello-world</id>
    <content type="html"><![CDATA[<p>Hello Dylandy here, this is the new blog for me. Maybe somebody use to see my privious blog on <a href="http://dylandychat.blogspot.com">blogger</a> which would probobly not update so far.<br/></p>

<p>This blog will content something about technologies, something around me and maybe some politic thinking about Taiwan as well. <br/></p>

<p>Hello, 我是迪蘭帝，經過一段時間的醞釀以後，我決定將部落格從原本的 <a href="http://dylandychat.blogspot.com">blogger</a> 搬家到 github page 上了，blogger 雖然提供了許多方便的功能，但是畢竟已經跟不上時代的腳步，
醜醜的 <a href="https://en.wikipedia.org/wiki/Responsive_web_design">RWD</a> 介面，不容易自訂 style &hellip; 等等的缺陷，所以在最近決定跳槽了。<br/></p>

<p>歡迎來到 Dylandy&rsquo;s Murmur ，翻翻我的技術筆記與聽聽我的一些牢騷，希望能夠為這個枯燥的網路帶來一些有趣的聲音。</p>
]]></content>
  </entry>
  
</feed>
